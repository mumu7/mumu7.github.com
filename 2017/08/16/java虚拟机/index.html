<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> java虚拟机运行时内存分区 · Hexo</title><meta name="description" content="java虚拟机运行时内存分区 - li.wang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/3774399350?is_all=1" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://www.zhihu.com/people/li.wang/activities" target="_blank" class="nav-list-link">ZHIHU</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">java虚拟机运行时内存分区</h1><div class="post-info">Aug 16, 2017</div><div class="post-content"><hr>
<p>Java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，<br>主要包括：<strong>方法区、虚拟机栈、本地方法栈、堆、程序计数器</strong>。其中，java堆和方法区是<strong>线程共享的数据区</strong>，其他几个都属于<strong>线程私有的</strong>。</p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器:"></a>程序计数器:</h4><p>程序计数器是一块较小的内存空间，它的作用可以看做是<strong>当前线程所执行的字节码的行号指示器</strong> ，字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，<strong>分支、循环、跳转、异常处理、线程恢复</strong>等基础功能都需要依赖这个计数器来完成。</p>
<p>如果线程正在执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器的值为空（undefined）<br>此内存区域是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何情况的<code>OutofMemoryError</code>区域</p>
<h4 id="Java虚拟机栈："><a href="#Java虚拟机栈：" class="headerlink" title="Java虚拟机栈："></a>Java虚拟机栈：</h4><p>虚拟机栈描述的是Java方法执行的内存模型，每个方法被执行的时候都会创建一个线帧，用于存储 <code>局部变量表、操作栈、动态链接、方法出口</code>等信息。每一个方法 被调用至执行完成的过程，就对应着一个线帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>我们通常把Java内存区分为<code>堆内存和栈内存</code>。</p>
<blockquote>
<p>栈内存指的就是现在所讲的虚拟机栈，或者说是   虚拟机栈中局部  变量表部分.<br> 局部变量表所需的内存空间在编译期间完成分配。<br> 在方法运行期间不会改变局部变量表的大小<br> 在java虚拟机栈中，规定了两个异常，<code>StackOverflowError</code>和  <code>OutOfMemoryError</code>异常</p>
</blockquote>
<a id="more"></a>
<h4 id="本地方法栈："><a href="#本地方法栈：" class="headerlink" title="本地方法栈："></a>本地方法栈：</h4><p>本地方法栈和虚拟机栈所发挥的作用非常相似，<strong>区别在于虚拟机栈为虚拟机执行java方法，而本地方法栈则为虚拟机执行native方法</strong>。<br>有些虚拟机（如HotSpot）直接把本地方法栈和虚拟机栈合二为一</p>
<h4 id="java堆："><a href="#java堆：" class="headerlink" title="java堆："></a>java堆：</h4><blockquote>
<p>java堆是java虚拟机所管理的内存中<strong>最大的</strong>一块。<br>java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。在此内存区域的唯一目的就是存放对象实例，<strong>几乎所有的对象实例</strong>都在这里分配内存。<br>java堆是<strong>垃圾回收器管理的主要区域</strong>，因此很多时候被称为”GC堆”</p>
</blockquote>
<p>Java堆可以处于物理上不连续的内存空间，只要逻辑上连续的即可。在实现上，既可以实现固定大小的，也可以是扩展的。<br>由于现在收集器基本上都是采用分代收集算法，所以java堆中可以细分为：<code>新生代</code>和<code>老年代</code>。<br>在细致一点可以分为：Eden空间、 From Survivor空间、To Survivor空间等。<br>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常</p>
<h4 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h4><p>方法区与java堆类似，是各个线程共享的内存区域，它用于存储已<strong>被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据<br>当方法区无法满足内存分配需求时，将会抛出<code>OutOfMemoryError</code>异常</p>
<h4 id="运行时常量池："><a href="#运行时常量池：" class="headerlink" title="运行时常量池："></a>运行时常量池：</h4><p>运行时常量是方法区的一部分。用于存放<strong>编译期生成的各种字面量和符号的引用</strong>，这部分内容将在类加载后 进入方法区的运行时常量池中存放。<br>除了保存class文件中描述的符号引用外，还会把<strong>翻译出来的直接引用</strong>也存储在运行时常量池。<br>运行常量池相对于class文件常量池的另一个重要特性是<strong>具备动态性</strong>.<br>java语言并不是要求常量一定在编译期产生，也就是说并非预置入class文件的常量池的内容才能进入运行常量池，运行期间也可以将新的常量放入池中。例如<code>String的intern()</code>方法<br>这部分会抛出<code>OutOfMemoryError</code>异常</p>
<h4 id="个人见解："><a href="#个人见解：" class="headerlink" title="个人见解："></a>个人见解：</h4><p><strong>程序计数器</strong>：存放当前线程所执行字节码的行号<br><strong>本地方法栈</strong>：作用与虚拟机栈类似，区别在于执行的为native方法<br><strong>java堆</strong>：存放对象实例<br><strong>方法区</strong>：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据<br><strong>运行时候常量池</strong>：存放编译期生成的各种字面量和符号的引用和翻译出来的直接引用<br><strong>java虚拟机栈</strong>：描述Java方法执行的内存模型，存放存储局部变量表、操作栈、动态链接、方法出口等信息<br>局部变量表：存放编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用类型和returnAddress类型</p>
<p>《深入理解java虚拟机（第二版）》周志明 读书笔记<br>近期才开始写博客，有理解错误或者不完善的地方 可以发邮件给我，谢谢<br>wangli_it@163.com</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/08/16/linux学习（centos6）/" class="prev">PREV</a><a href="/2017/08/16/跟阿铭学linux第三版/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 <a href="http://yoursite.com">li.wang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>